---
image: /posts/rxjs.png
title: "驴Qu茅 c* es rxjs y c贸mo usarlo en Angular?"
subtitle: "La programaci贸n reactiva es un paradigma de programaci贸n que se centra en el flujo de datos y la propagaci贸n de cambios."
date: "25-10-2023"
---

![github](/posts/rxjs.png "rxjs")

### Table of Contents

## 驴Qu茅 es rxjs?

Angular como framework contiene much铆simas funcionalidades y librer铆as reactivas. Y una de ellas, si no la m谩s importante o la que m谩s se usa, es Rxjs.

RxJS es una librer铆a de JavaScript que se utiliza para programaci贸n reactiva. La programaci贸n reactiva es un paradigma de programaci贸n que se centra en el flujo de datos y la propagaci贸n de cambios. RxJS se basa en el patr贸n Observador (Observer) y proporciona una forma eficiente y eficaz de trabajar con flujos de datos as铆ncronos, como eventos, solicitudes HTTP, y otros tipos de datos que cambian con el tiempo.

**RxJS se basa en el concepto de "observables".**

Los observables son secuencias de eventos o datos que pueden ser observados y reaccionados a medida que se emiten. Los observables pueden ser operados y transformados de diversas maneras para realizar tareas como filtrar datos, mapearlos, combinarlos, o manejar errores de manera elegante.

La biblioteca Rxjs es especialmente 煤til en aplicaciones web y m贸viles donde la interacci贸n del usuario, las notificaciones de eventos, y las llamadas a servicios web son comunes. Al adoptar Rxjs, los desarrolladores pueden escribir c贸digo m谩s limpio y mantenible para manejar de manera eficiente flujos de datos as铆ncronos y reactivos.

Vamos, de forma resumida, RxJS es una biblioteca de JavaScript que facilita la programaci贸n reactiva al **proporcionar una amplia gama de herramientas y operadores para trabajar con flujos de datos as铆ncronos de una manera m谩s eficiente y manejable.**

## Ejemplo de uso te贸rico con `map()` , `filter()` y `take()`

En el ejemplo que muestro a continuaci贸n importamos `from`, `of`,`interval`de `rxj`, que nos permitir谩n convertir datos en observables. Tambi茅n importamos `map`, `filter` y `take` de la carpeta de operadores de rxjs, de forma que podamos mapear o filtrar los observables que hayamos creado.

```jsx
// Importa la biblioteca RxJS
const { from, of, interval } = require("rxjs");
const { map, filter, take } = require("rxjs/operators");

// Crear un observable a partir de una matriz
const numeros = from([1, 2, 3, 4, 5]);

// Aplicar una operaci贸n de mapeo para duplicar cada n煤mero
const numerosDuplicados = numeros.pipe(map((numero) => numero * 2));

// Filtrar n煤meros mayores que 5
const numerosFiltrados = numerosDuplicados.pipe(filter((numero) => numero > 5));

// Tomar solo los primeros 3 n煤meros
const primerosTresNumeros = numerosFiltrados.pipe(take(3));

// Suscribirse al observable resultante y observar los valores emitidos
primerosTresNumeros.subscribe(
  (numero) => console.log(numero),
  (error) => console.error("Error:", error),
  () => console.log("Terminado")
);
```

## Ejemplo de uso pr谩ctico con `mergeMap()` y `catchError()`

Puedes utilizar **`mergeMap`** para manejar solicitudes HTTP anidadas, como cuando necesitas cargar datos dependiendo de los resultados de otra solicitud. Por ejemplo, supongamos que tienes una solicitud inicial para obtener un usuario y luego deseas obtener las tareas de ese usuario:

```tsx
import { Component } from "@angular/core";
import { UserService } from "./user.service";

@Component({
  selector: "app-user-tasks",
  template: `
    <ul>
      <li *ngFor="let task of userTasks$ | async">{{ task.name }}</li>
    </ul>
  `,
})
export class UserTasksComponent {
  userTasks$ = this.userService
    .getUser(1)
    .pipe(mergeMap((user) => this.taskService.getTasks(user.id)));

  constructor(
    private userService: UserService,
    private taskService: TaskService
  ) {}
}
```

De igual forma, puedes utilizar el operador **`catchError`** para manejar errores de observables, como errores en solicitudes HTTP. Por ejemplo, si deseas mostrar un mensaje de error cuando una solicitud falla:

```tsx
import { Component } from "@angular/core";
import { UserService } from "./user.service";

@Component({
  selector: "app-user-details",
  template: `
    <div *ngIf="user$; else errorTemplate">
      <p>Nombre: {{ user$.name }}</p>
    </div>
    <ng-template #errorTemplate>
      <p>Hubo un error al cargar el usuario.</p>
    </ng-template>
  `,
})
export class UserDetailsComponent {
  user$ = this.userService.getUser(1).pipe(
    catchError((error) => {
      console.error("Error:", error);
      return throwError("Error al cargar el usuario");
    })
  );

  constructor(private userService: UserService) {}
}
```

## M茅todo 1 para suscripciones as铆ncronas: `async` pipe

El operador **`async`** en Angular es una caracter铆stica que se utiliza para simplificar la gesti贸n de observables en las plantillas de tus componentes. B谩sicamente, permite que Angular se encargue de suscribirse y desuscribirse autom谩ticamente de los observables, lo que reduce la necesidad de gestionar manualmente la suscripci贸n y desuscripci贸n en tus componentes. El uso principal del operador **`async`** es en las plantillas, especialmente en el contexto de Angular.

Principales ventajas:

1. **Uso en plantillas:** En lugar de suscribirte manualmente en el componente y asignar los datos a propiedades del componente, puedes usar **`async`** directamente en la plantilla para mostrar los datos.
2. **Manejo autom谩tico de la suscripci贸n y desuscripci贸n**: Cuando utilizas **`async`** en una plantilla, Angular se encarga autom谩ticamente de suscribirse al observable cuando se muestra la vista y de desuscribirse cuando se destruye la vista o se cambia el componente. Esto evita problemas de fuga de memoria y garantiza que la suscripci贸n se gestione de manera segura y eficiente.
3. **Actualizaci贸n autom谩tica**: Cuando el observable emite nuevos valores, la vista se actualizar谩 autom谩ticamente para reflejar esos cambios, sin necesidad de escribir c贸digo adicional.

```tsx
import { Component } from "@angular/core";
import { MyCarDataService } from "./mi-servicio"; // Importa tu servicio aqu铆

@Component({
  selector: "app-car-component",
  template: `
    <div>
      <h2>Matr铆cula del coche:</h2>
      <p>{{ carData$ | async }}</p>
    </div>
  `,
})
export class MyCarComponent {
  // Supongamos que el servicio retorna un observable con la matr铆cula del coche

  carData$ = this._myCarData.obtainCarData();
  constructor(private _myCarData: MyCarDataService) {}
}
```

隆De esta forma pasamos directamente el observable al template y nos olvidamos de la desuscripci贸n!

## M茅todo 2 para suscripciones as铆ncronas: suscripci贸n manual.

En general, el uso del operador **`async`** es muy recomendable, ya que automatiza la gesti贸n de suscripciones y desuscripciones, lo que simplifica considerablemente el c贸digo y ayuda a evitar problemas como las fugas de memoria.

Sin embargo, en algunos casos particulares, puede ser necesario realizar la suscripci贸n manualmente, por ejemplo, **cuando necesitas un mayor control sobre la l贸gica de suscripci贸n o cuando trabajas con observables m谩s complejos**.

A continuaci贸n, te proporcionar茅 un ejemplo en el que la suscripci贸n debe ser manual porque la l贸gica de manejo de eventos espec铆ficos es m谩s compleja de lo que el operador **`async`** puede manejar de manera directa.

Supongamos que est谩s trabajando con un observable de eventos de rat贸n en Angular y deseas realizar una l贸gica personalizada para procesar estos eventos. Aqu铆 hay un ejemplo en el que necesitas realizar la suscripci贸n manualmente:

```tsx
import {
  Component,
  ElementRef,
  OnInit,
  OnDestroy,
  AfterViewInit,
} from "@angular/core";
import { fromEvent, Subscription } from "rxjs";

@Component({
  selector: "app-mi-componente",
  template: `
    <div
      #miElemento
      style="width: 100px; height: 100px; background-color: red;"
    ></div>
  `,
})
export class MiComponente implements AfterViewInit, OnDestroy {
  private mouseMoveSubscription: Subscription;
  private elemento: HTMLElement;

  constructor(private el: ElementRef) {}

  ngAfterViewInit() {
    // Acceder al elemento DOM una vez que est茅 disponible
    this.elemento = this.el.nativeElement;

    // Crear un observable de eventos de rat贸n
    const mouseMove$ = fromEvent(this.elemento, "mousemove");

    // Realizar la suscripci贸n manualmente
    this.mouseMoveSubscription = mouseMove$.subscribe((event: MouseEvent) => {
      // Realizar l贸gica personalizada con los eventos del rat贸n
      const offsetX =
        event.clientX - this.elemento.getBoundingClientRect().left;
      const offsetY = event.clientY - this.elemento.getBoundingClientRect().top;
      this.elemento.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
    });
  }

  ngOnDestroy() {
    // Desuscribirse para evitar fugas de memoria
    this.mouseMoveSubscription.unsubscribe();
  }
}
```

En este ejemplo:

1. Creamos un componente que tiene un elemento HTML que queremos seguir con el rat贸n.
2. Usamos **`fromEvent`** para crear un observable de eventos de rat贸n en ese elemento.
3. Realizamos la suscripci贸n manualmente en el m茅todo `**ngAfterViewInit**`, lo que nos permite personalizar la l贸gica para mover el elemento div en respuesta a eventos de rat贸n.
4. Nos desuscribimos en el m茅todo **`ngOnDestroy`** para evitar fugas de memoria.

En este escenario, es necesario realizar la suscripci贸n manualmente ya que estamos implementando una l贸gica personalizada para manejar los eventos de rat贸n. El operador **`async`** no es adecuado en este caso, ya que no nos proporciona suficiente control sobre el comportamiento del elemento.

## Desuscripciones:

Como comentaba anteriormente, una de las pr谩cticas recomendadas a la hora de programar es desuscribirnos de todos aquellos observables. De esta forma conseguimos:

1. **Liberaci贸n de recursos**: Cuando te suscribes a un observable, se establece una conexi贸n para escuchar eventos o recibir datos. Si no te desuscribes cuando ya no necesitas los datos, la conexi贸n seguir谩 activa, lo que podr铆a consumir recursos innecesarios como memoria y poder de procesamiento.
2. **Prevenci贸n de p茅rdida de memoria**: Las suscripciones no desechadas pueden llevar a una fuga de memoria en tu aplicaci贸n. Si no te desuscribes, los observables y los objetos relacionados pueden quedar en memoria incluso cuando ya no se utilizan. Esto puede hacer que tu aplicaci贸n se vuelva m谩s lenta con el tiempo y, en casos extremos, agotar la memoria y hacer que la aplicaci贸n se bloquee.
3. **Mantenimiento del estado consistente**: En aplicaciones donde se gestionan estados, como las aplicaciones Angular, una suscripci贸n no desuscrita puede llevar a un estado inconsistente. Puedes recibir datos que cambian el estado de la aplicaci贸n, y si no se desuscribe adecuadamente, es posible que tu aplicaci贸n se comporte de manera inesperada.
4. **Evitar comportamientos no deseados**: En situaciones donde una suscripci贸n est谩 vinculada a un componente o servicio espec铆fico, la falta de desuscripci贸n puede causar comportamientos inesperados cuando se cambia de componente o se destruye un componente.
5. **Reducci贸n de errores potenciales**: Al desuscribirte adecuadamente, reduces la posibilidad de errores o comportamientos inesperados en tu aplicaci贸n. Las suscripciones no desechadas pueden causar efectos secundarios no deseados y dificultar la depuraci贸n.

### Usando el propio ciclo de vida del componente (`async` pipe).

Cuando hacemos uso del pipe `async` no necesitamos realizar ninguna desuscripci贸n manual desde nuestro componente.

```tsx
 <p>{{ carData$ | async }}</p>
```

### M茅todo `unsubscribe()`

Cada suscripci贸n a un observable en RxJS retorna un objeto Subscription. Puedes llamar al m茅todo **`unsubscribe()`** en este objeto para desuscribirte de la suscripci贸n cuando se produzca el ciclo de vida `ngOnDestroy` del componente. Sin embargo, esto genera problemas de [boilerplate](https://en.wikipedia.org/wiki/Boilerplate_code)

Por ejemplo:

```tsx
@Component(...)
export class MyComponent implements OnDestroy {
  private subscription: Subscription; // boilerplate
  constructor(private apiService: MyApiService) {}
  public ngOnInit(): void {
    this.subscription = this.apiService // boilerplate
      .callSomeServerApi()
      .subscribe(() => window.location = 'https://another.site`)
  }
public ngOnDestroy(): void {
    if (this.subscription) { // boilerplate
      this.subscription.unsubscribe(); // boilerplate
    } // boilerplate
  }
}
```

### Usando el operador `takeUntil()`

Puedes usar el operador **`takeUntil()`** en combinaci贸n con otro observable que emita un valor para indicar cu谩ndo deseas desuscribirte. Aqu铆 tienes un ejemplo:

```tsx
import { fromEvent, interval } from "rxjs";
import { takeUntil } from "rxjs/operators";

const clickObservable = fromEvent(document, "click");
const intervalObservable = interval(1000);

const unsubscribeSignal = fromEvent(document, "keydown"); // Cuando se presiona una tecla, se desuscribe

clickObservable
  .pipe(takeUntil(unsubscribeSignal))
  .subscribe((event) => console.log("Click detectado:", event));
```

### Funci贸n `AutoUnsubscribe()`

Esta es, en mi opini贸n, la forma m谩s elegante de controlar las suscripciones de forma global en nuestra aplicaci贸n. Observa el c贸digo con detenimiento y despu茅s lee la explicaci贸n:

```jsx
export function AutoUnsubscribe(blacklist: string[] = []) {
  return function (constructor: any) {
    const original = constructor.prototype.ngOnDestroy;

    constructor.prototype.ngOnDestroy = function () {
      for (const prop of Object.keys(this)) {
        const property = this[prop];
        if (!blacklist.includes(prop)) {
          if (property && typeof property.unsubscribe === 'function') {
            property.unsubscribe();

          }
        }
      }
      original &&
        typeof original === 'function' &&
        original.apply(this, arguments);
    };
  };
}
```

Esta funci贸n es un decorador en TypeScript que se utiliza para automatizar la desuscripci贸n de observables en componentes; acepta un par谩metro opcional **`blacklist`**, que es una matriz de nombres de propiedades que se deben excluir de la desuscripci贸n autom谩tica.

Cuando aplicas este decorador a una clase de componente de Angular, reemplaza el m茅todo **`ngOnDestroy`** del componente con una versi贸n personalizada. Esta versi贸n personalizada del m茅todo **`ngOnDestroy`** se encarga de recorrer todas las propiedades del componente y desuscribir cualquier observable presente en esas propiedades, a menos que el nombre de la propiedad est茅 en la lista negra especificada en el par谩metro **`blacklist`**. Aqu铆 est谩 el flujo de lo que hace la funci贸n:

1. Reemplaza el m茅todo **`ngOnDestroy`** del componente con una funci贸n personalizada.
2. En la funci贸n personalizada, itera sobre todas las propiedades del componente utilizando un bucle **`for...of`**.
3. Para cada propiedad, verifica si no est谩 en la lista negra (**`blacklist`**) especificada.
4. Si la propiedad no est谩 en la lista negra, comprueba si es un objeto y si tiene un m茅todo **`unsubscribe`**. Si ambas condiciones se cumplen, llama al m茅todo **`unsubscribe`** en esa propiedad para desuscribirse.
5. Luego, verifica si el m茅todo **`ngOnDestroy`** original exist铆a y era una funci贸n antes de llamarlo. Esto es importante porque si el componente ten铆a un **`ngOnDestroy`** original, a煤n se ejecutar谩 despu茅s de desuscribirse de los observables.
6. Llama al m茅todo **`ngOnDestroy`** original si existe y era una funci贸n, pas谩ndole los mismos argumentos que se le pasaron a la funci贸n personalizada.

**`AutoUnsubscribe`** es 煤til para automatizar la desuscripci贸n de observables en componentes de Angular, evitando as铆 posibles fugas de memoria causadas por observables no desuscritos adecuadamente. Adem谩s, proporciona una lista negra opcional para excluir propiedades espec铆ficas de la desuscripci贸n autom谩tica si es necesario.

```tsx
import { AutoUnsubscribe } from '@helpers';
import { Subscription } from 'rxjs';
import {CustomService } from '@services'

export class YourComponent {
	subscription = new Subscription()
	constructor(
			private: _service: CustomService
	) {
		//y ya est谩! Aqu铆 tienes tu suscripci贸n sin necesidad de desuscribirte desde el componente.
		this.subscription = this._service.getData().subscribe()
  	}
}
```

Y ya est谩. 

Autom谩ticamente cuando el componente de destruya se ejecutar谩 la funci贸n y se desuscribir谩, evitando as铆 problemas de memoria.

Te recomiendo que visites la documentaci贸n oficial de RxJS para ver el funcionamiento y todos los operadores disponibles: [https://rxjs.dev/api](https://rxjs.dev/api)

Si te ha gustado este art铆culo no dudes en compartirlo en tus redes. 

chale un vistazo a mi [blog](https://blog.bmrd.dev/), donde podr谩s encontrar m谩s art铆culos sobre Angular.
